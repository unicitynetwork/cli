# CRITICAL SECURITY BUG: Request ID Format Mismatch (256-bit vs 272-bit)

## Executive Summary

**Severity**: CRITICAL
**Impact**: Aggregator crashes when querying request IDs generated by CLI
**Root Cause**: User confusion about RequestId format - users may copy incomplete hex strings
**Status**: Identified - Fix Required

## Bug Description

### The Problem

When users run `register-request`, they receive a Request ID. However, if they use an incomplete format when calling `get-request`, the aggregator crashes with:

```
panic: invalid key length 256, should be 272
fatal error: nil pointer dereference at service.go:202
```

### Technical Root Cause

**RequestId Structure**:
- A `RequestId` is a `DataHash` which consists of:
  - **2 bytes**: Algorithm identifier (e.g., `0x0000` for SHA256)
  - **32 bytes**: Hash data (the actual SHA256 output)
  - **Total: 34 bytes = 272 bits**

**The Bug**:
Users may see examples or mistakenly copy only the hash data portion (32 bytes = 256 bits) instead of the full imprint (34 bytes = 272 bits), causing the aggregator to reject the request.

## Reproduction Steps

### Step 1: Register a Request

```bash
npm run register-request -- "test-secret" "test-state" "test-transaction"
```

**Output**:
```
Request ID: 0000ecbf70baaa355dc2d52a6a565fc3838b8da34df3ee062dbdedb86abf0e6c6055
            ^^^^ <-- 2-byte algorithm prefix (SHA256 = 0x0000)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ <-- 32-byte hash data
```

**Correct Format**: 68 hex characters (34 bytes = 272 bits)

### Step 2: Query with Incorrect Format (CAUSES CRASH)

If user mistakenly uses only the hash portion:
```bash
npm run get-request -- ecbf70baaa355dc2d52a6a565fc3838b8da34df3ee062dbdedb86abf0e6c6055
# Missing the "0000" prefix!
```

**Result**: Aggregator crashes with "invalid key length 256, should be 272"

### Step 3: Query with Correct Format (WORKS)

```bash
npm run get-request -- 0000ecbf70baaa355dc2d52a6a565fc3838b8da34df3ee062dbdedb86abf0e6c6055
# Full 68 hex chars including "0000" prefix
```

**Result**: Success - returns inclusion proof

## Detailed Technical Analysis

### RequestId Generation Flow

**File**: `/home/vrogojin/cli/src/commands/register-request.ts:48`
```typescript
const requestId = await RequestId.create(signingService.publicKey, stateHash);
console.log(`Request ID: ${requestId.toJSON()}\n`);
```

**File**: `/home/vrogojin/cli/node_modules/@unicitylabs/state-transition-sdk/lib/api/RequestId.js:24-35`
```javascript
static async createFromImprint(id, hashImprint) {
    const hash = await new DataHasher(HashAlgorithm.SHA256)
        .update(id)           // publicKey (32 bytes)
        .update(hashImprint)  // stateHash.imprint (34 bytes)
        .digest();
    return new RequestId(hash);
}
```

**Formula**:
```
RequestId = SHA256(publicKey || stateHash.imprint)
         = DataHash(algorithm=SHA256, data=32-byte-hash)

RequestId.toJSON() = HexConverter.encode(imprint)
                   = HexConverter.encode([2-byte-algo][32-byte-data])
                   = 68 hex characters
```

### Serialization (CORRECT)

**File**: `/home/vrogojin/cli/node_modules/@unicitylabs/state-transition-sdk/lib/hash/DataHash.js:42-44`
```javascript
toJSON() {
    return HexConverter.encode(this._imprint);  // ✓ Uses full imprint (34 bytes)
}
```

**File**: `/home/vrogojin/cli/node_modules/@unicitylabs/state-transition-sdk/lib/api/RequestId.js:50-52`
```javascript
static fromJSON(data) {
    return new RequestId(DataHash.fromJSON(data));
}
```

**File**: `/home/vrogojin/cli/node_modules/@unicitylabs/state-transition-sdk/lib/hash/DataHash.js:36-38`
```javascript
static fromJSON(data) {
    return DataHash.fromImprint(HexConverter.decode(data));
}
```

### The Imprint Structure

**File**: `/home/vrogojin/cli/node_modules/@unicitylabs/state-transition-sdk/lib/hash/DataHash.js:14-16`
```javascript
constructor(algorithm, _data) {
    this.algorithm = algorithm;
    this._data = _data;
    this._data = new Uint8Array(_data);
    this._imprint = new Uint8Array(_data.length + 2);  // +2 for algorithm
    this._imprint.set([(algorithm & 0xff00) >> 8, algorithm & 0xff]);  // First 2 bytes
    this._imprint.set(new Uint8Array(_data), 2);  // Remaining bytes
}
```

**Breakdown**:
- Byte 0-1: Algorithm identifier (0x0000 for SHA256)
- Byte 2-33: Hash data (32 bytes from SHA256)
- Total: 34 bytes = 272 bits

### Why Users Get Confused

**File**: `/home/vrogojin/cli/README.md:124`
```bash
npm run get-request -- -e https://gateway.unicity.network 7c8a9b0f1d2e3f4a5b6c7d8e9f0a1b2c
                                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                                                          Only 32 characters shown!
```

This example shows a 32-character hex string, which suggests 16 bytes (128 bits), but a proper RequestId should be 68 characters (34 bytes = 272 bits).

## Evidence of the Bug

### Test Demonstration

**File**: `/home/vrogojin/cli/reproduce_bug.js`

```javascript
// Correct RequestId (with algorithm prefix)
Request ID: 0000ecbf70baaa355dc2d52a6a565fc3838b8da34df3ee062dbdedb86abf0e6c6055
Length: 68 hex chars (34 bytes = 272 bits)

// Incorrect (hash data only, missing prefix)
Hash Data Only: ecbf70baaa355dc2d52a6a565fc3838b8da34df3ee062dbdedb86abf0e6c6055
Length: 64 hex chars (32 bytes = 256 bits)
```

**Result**:
- Parsing correct format: ✓ Success (34-byte imprint = 272 bits)
- Parsing hash-only format: ✓ Parses but incorrectly (32-byte imprint = 256 bits)
- Aggregator rejects 256-bit keys: ❌ "invalid key length 256, should be 272"

## Impact Assessment

### Security Impact

**HIGH SEVERITY**:
1. **Denial of Service**: Aggregator crashes when invalid RequestId format is used
2. **Data Corruption Risk**: Malformed RequestIds could be misinterpreted
3. **User Confusion**: Users may lose access to their registered commitments

### Affected Components

1. **CLI Commands**:
   - `/home/vrogojin/cli/src/commands/register-request.ts` (Line 49, 82, 86)
   - `/home/vrogojin/cli/src/commands/get-request.ts` (Line 58)

2. **Documentation**:
   - `/home/vrogojin/cli/README.md` (Line 124)

3. **SDK**:
   - Correctly implements serialization (no bug in SDK)

4. **Aggregator**:
   - Expects 272-bit (34-byte) RequestIds
   - Crashes on 256-bit (32-byte) input

## Root Cause Analysis

### Where is the Bug?

**NOT in the CLI code** - The CLI correctly generates and serializes RequestIds as 68-character hex strings (272 bits).

**NOT in the SDK** - The SDK correctly uses the full imprint (272 bits) when serializing.

**Bug Location**: **Documentation and User Education**
- README example shows incomplete RequestId format
- No validation or error message when user provides wrong format
- Users may copy only the hash portion from logs or examples

### Why Does It Parse Incorrectly?

**File**: `/home/vrogojin/cli/node_modules/@unicitylabs/state-transition-sdk/lib/hash/DataHash.js:29-35`
```javascript
static fromImprint(imprint) {
    if (imprint.length < 3) {
        throw new HashError('Imprint must have 2 bytes of algorithm and at least 1 byte of data.');
    }
    const algorithm = (imprint[0] << 8) | imprint[1];
    return new DataHash(algorithm, imprint.subarray(2));
}
```

**The Problem**:
- If user provides 64 hex chars (32 bytes), it passes validation (32 > 3)
- First 2 bytes are interpreted as algorithm (incorrect)
- Remaining 30 bytes treated as hash data (incorrect)
- Creates a malformed RequestId with wrong structure

## Recommended Fixes

### Fix 1: Validate RequestId Format in get-request Command

**File**: `/home/vrogojin/cli/src/commands/get-request.ts:58`

**Current Code**:
```typescript
const requestId = RequestId.fromJSON(requestIdStr);
```

**Proposed Fix**:
```typescript
// Validate RequestId format before parsing
if (!/^[0-9a-f]{68}$/i.test(requestIdStr)) {
    console.error('❌ Invalid RequestId format!');
    console.error('Expected: 68 hexadecimal characters (34 bytes = 272 bits)');
    console.error('Example: 0000ecbf70baaa355dc2d52a6a565fc3838b8da34df3ee062dbdedb86abf0e6c6055');
    console.error(`Received: ${requestIdStr} (${requestIdStr.length} characters)`);
    process.exit(1);
}

const requestId = RequestId.fromJSON(requestIdStr);

// Additional validation: check imprint length
if (requestId.imprint.length !== 34) {
    console.error('❌ Invalid RequestId structure!');
    console.error(`Expected imprint size: 34 bytes (272 bits)`);
    console.error(`Actual imprint size: ${requestId.imprint.length} bytes (${requestId.imprint.length * 8} bits)`);
    process.exit(1);
}
```

### Fix 2: Update README.md Example

**File**: `/home/vrogojin/cli/README.md:122-125`

**Current**:
```bash
npm run get-request -- -e https://gateway.unicity.network 7c8a9b0f1d2e3f4a5b6c7d8e9f0a1b2c
```

**Proposed**:
```bash
# Get inclusion proof for a RequestId (must be 68 hex characters)
npm run get-request -- -e https://gateway.unicity.network 0000ecbf70baaa355dc2d52a6a565fc3838b8da34df3ee062dbdedb86abf0e6c6055

# RequestId Format:
#   - First 4 hex chars (2 bytes): Algorithm identifier (0000 = SHA256)
#   - Next 64 hex chars (32 bytes): Hash data
#   - Total: 68 hex chars (34 bytes = 272 bits)
```

### Fix 3: Add Validation in SDK (Upstream)

**File**: `@unicitylabs/state-transition-sdk/lib/hash/DataHash.js:29-35`

**Proposed Enhancement**:
```javascript
static fromImprint(imprint) {
    if (imprint.length < 3) {
        throw new HashError('Imprint must have 2 bytes of algorithm and at least 1 byte of data.');
    }

    // Validate imprint structure
    const algorithm = (imprint[0] << 8) | imprint[1];
    const dataLength = imprint.length - 2;

    // For SHA256 (0x0000), expect exactly 32 bytes of data
    if (algorithm === 0x0000 && dataLength !== 32) {
        throw new HashError(
            `Invalid SHA256 hash: expected 32 bytes of data, got ${dataLength} bytes. ` +
            `Imprint should be 34 bytes (272 bits), got ${imprint.length} bytes (${imprint.length * 8} bits).`
        );
    }

    return new DataHash(algorithm, imprint.subarray(2));
}
```

### Fix 4: Enhance register-request Output

**File**: `/home/vrogojin/cli/src/commands/register-request.ts:86`

**Current**:
```typescript
console.log(`  npm run get-request -- ${requestId.toJSON()}`);
```

**Proposed**:
```typescript
const requestIdHex = requestId.toJSON();
console.log('\nYou can check the inclusion proof with:');
console.log(`  npm run get-request -- ${requestIdHex}`);
console.log('\nIMPORTANT: Use the FULL 68-character RequestId shown above.');
console.log(`  ✓ Correct format: ${requestIdHex} (68 hex chars)`);
console.log(`  ✗ Do NOT use only the hash portion (64 hex chars)`);
```

## Test Cases

### Test Case 1: Valid RequestId (272 bits)

```bash
# Input
requestId="0000ecbf70baaa355dc2d52a6a565fc3838b8da34df3ee062dbdedb86abf0e6c6055"

# Expected
- Length: 68 characters
- Parsed imprint: 34 bytes
- Aggregator: Accepts query
```

### Test Case 2: Invalid RequestId - Hash Only (256 bits)

```bash
# Input
requestId="ecbf70baaa355dc2d52a6a565fc3838b8da34df3ee062dbdedb86abf0e6c6055"

# Expected
- Length: 64 characters
- CLI validation: REJECT with clear error message
- Aggregator: Never receives invalid request
```

### Test Case 3: Invalid RequestId - Too Short

```bash
# Input
requestId="0000abcd"

# Expected
- Length: 8 characters
- CLI validation: REJECT with clear error message
```

### Test Case 4: Invalid RequestId - Non-Hex Characters

```bash
# Input
requestId="0000xyz123..."

# Expected
- CLI validation: REJECT with clear error message
```

## Verification Steps

Run the following commands to verify the fix:

```bash
# Step 1: Generate a valid RequestId
npm run register-request -- "test-secret" "test-state" "test-transaction" > output.txt

# Step 2: Extract the RequestId (should be 68 chars)
REQUEST_ID=$(grep "Request ID:" output.txt | awk '{print $3}')
echo "Length: ${#REQUEST_ID} characters"  # Should be 68

# Step 3: Test with correct format
npm run get-request -- $REQUEST_ID  # Should succeed

# Step 4: Test with incorrect format (hash only - 64 chars)
HASH_ONLY="${REQUEST_ID:4}"  # Remove first 4 chars (algorithm prefix)
echo "Hash only length: ${#HASH_ONLY} characters"  # Should be 64
npm run get-request -- $HASH_ONLY  # Should fail with clear error message
```

## Priority and Timeline

**Priority**: P0 (Critical)
**Timeline**: Immediate fix required
**Estimated Effort**: 2-4 hours

### Implementation Order

1. **Immediate** (30 min): Fix README example
2. **Short-term** (1 hour): Add validation in get-request command
3. **Short-term** (1 hour): Enhance register-request output
4. **Long-term** (1-2 weeks): Work with SDK team to add upstream validation

## Related Files

### CLI Source Files
- `/home/vrogojin/cli/src/commands/register-request.ts:48-49, 82, 86`
- `/home/vrogojin/cli/src/commands/get-request.ts:58`

### SDK Files (Read-Only - No Changes)
- `/home/vrogojin/cli/node_modules/@unicitylabs/state-transition-sdk/lib/api/RequestId.js:24-52`
- `/home/vrogojin/cli/node_modules/@unicitylabs/state-transition-sdk/lib/hash/DataHash.js:14-16, 29-44`

### Documentation
- `/home/vrogojin/cli/README.md:122-125`

### Test Files
- `/home/vrogojin/cli/reproduce_bug.js` (Created for bug reproduction)

## Conclusion

This is a **critical user experience and security bug** caused by:
1. Inadequate validation of RequestId format
2. Misleading documentation examples
3. No clear error messages when wrong format is provided

The CLI and SDK code correctly implement RequestId serialization (272 bits), but users can easily make mistakes by:
- Copying incomplete examples from documentation
- Using only the hash portion (256 bits) instead of full imprint (272 bits)

**Recommended Action**: Implement validation in the CLI immediately to prevent aggregator crashes and provide clear error messages to users.
